# Cool Compiler

A Compiler for the Cool Programming Language

## Table of Contents
- [Cool Compiler](#cool-compiler)
  - [Table of Contents](#table-of-contents)
  - [Introduction](#introduction)
  - [Features Implemented](#features-implemented)
    - [Lexer](#lexer)
    - [Example: Lexer Output](#example-lexer-output)
      - [Sample Cool Code](#sample-cool-code)
      - [Expected Tokens](#expected-tokens)
    - [Parser](#parser)
      - [Example AST Output](#example-ast-output)
      - [AST Tree:](#ast-tree)
    - [Semantic Analyzer](#semantic-analyzer)
    - [LLVM IR Generation](#llvm-ir-generation)
    - [Built-in Functions and Basic Classes](#built-in-functions-and-basic-classes)
      - [IO Class](#io-class)
      - [String Class](#string-class)
      - [Object Class](#object-class)
  - [Build and Installation Instructions](#build-and-installation-instructions)
    - [Prerequisites](#prerequisites)
    - [Build Steps](#build-steps)
    - [Running the Compiler](#running-the-compiler)
      - [Generate LLVM IR](#generate-llvm-ir)
      - [Compile to Executable](#compile-to-executable)
      - [Run the Executable](#run-the-executable)
      - [(Optional) Clean Up](#optional-clean-up)
  - [Testing](#testing)
    - [Test Cases](#test-cases)
    - [Running Tests](#running-tests)
  - [Extensions](#extensions)
    - [Module System](#module-system)
    - [Standard Library Extension: LinkedList](#standard-library-extension-linkedlist)
    - [Example Program](#example-program)
      - [Program Output](#program-output)
      - [This Example Demonstrates:](#this-example-demonstrates)

## Introduction
**Project Background:**  
_Provide a brief description of the project's motivation and goals._

**Language Description:**  
_Explain what the Cool language is and its key features (e.g., classes, inheritance, expressions)._

## Features Implemented
### Lexer
The lexer is a core part of the Cool Compiler project, responsible for breaking down raw Cool source code into a sequence of tokens that the parser can understand. this component reliably identifies all the fundamental elements of the language—keywords, identifiers, numbers, strings, as well as comments and whitespace. It also provides clear, detailed error messages with accurate line and column information to help pinpoint issues during development. 
### Example: Lexer Output

Below is a simple Cool program along with an example of the tokens that the lexer produces when processing the code.

#### Sample Cool Code
```cool
class Main inherits IO {
    main() : Object {
        out_string("Hello, World!")
    };
};
```
#### Expected Tokens

- **`class`** – Keyword indicating the start of a class definition.
- **`Main`** – Type identifier representing the class name.
- **`inherits`** – Keyword indicating that the class inherits from a parent class.
- **`IO`** – Type identifier representing the parent class.
- **`{`** – Opening brace for the class body.
- **`main`** – Identifier for the main method.
- **`(`** – Opening parenthesis for the method parameter list.
- **`)`** – Closing parenthesis for the method parameter list.
- **`:`** – Separator between the method name and its return type.
- **`Object`** – Type identifier indicating the return type of the method.
- **`{`** – Opening brace for the method body.
- **`out_string`** – Identifier for the function call.
- **`(`** – Opening parenthesis for the function call.
- **`"Hello, World!"`** – String literal.
- **`)`** – Closing parenthesis for the function call.
- **`}`** – Closing brace for the method body.
- **`;`** – Semicolon marking the end of the method declaration.
- **`}`** – Closing brace for the class body.
- **`;`** – Semicolon marking the end of the class definition.
  
This example shows how the lexer converts a simple Cool program into a structured sequence of tokens that are then used by the parser to build the Abstract Syntax Tree (AST). Feel free to adjust or expand the example to better match your project's specifics.
### Parser
The parser takes the token stream generated by the lexer and builds an Abstract Syntax Tree (AST) that represents the structure of a Cool program. It processes tokens according to the grammar rules of Cool, constructing nodes for classes, methods, expressions, and other constructs.

A key feature of the parser is its handling of arithmetic expressions using Pratt parsing. This technique elegantly manages operator precedence and associativity, enabling a clear and modular approach to parsing complex expressions. This ensures that arithmetic operations are correctly represented in the AST.

An integrated AST printer is also provided to visualize the tree structure, which greatly aids in debugging and understanding how the source code is interpreted.


#### Example AST Output
#### AST Tree:
```
└── Program  
    └── Class: Main  
        ├── Parent: IO  
        └── Method: main  
            ├── ReturnType: Object  
            └── Body:  
                └── FunctionCall: out_string  
                    └── Arguments:  
                        └── └── String: Hello, World!
```
In this example, the AST printer outputs a tree where the root node represents the entire program. Under it, a class node (`Main`) is shown with its parent (`IO`) and a method (`main`). The method node displays its return type (`Object`) and the body, which in this case is a function call to `out_string` with a string literal argument.

This structured representation helps verify that the parser correctly captures the program's structure, ensuring that each component is in its proper place within the AST.

### Semantic Analyzer

A semantic analyzer for the Cool language performs several crucial tasks to ensure that a program is well-formed and adheres to the language's rules. The primary role of the semantic analyzer is type checking, as Cool is a statically typed language where every expression's type must be determined at compile time. The analyzer verifies that the program respects Cool's type rules, ensuring that no runtime type errors occur during execution. This includes:

- **Type Inference:** Inferring a type for every expression based on the type declarations provided by the programmer.
- **Conformance Checking:** Ensuring that if a method or variable expects a value of type `P`, any value of type `C` is acceptable provided that `P` is an ancestor of `C` in the class hierarchy (i.e., `C ≤ P`).
- **Static vs. Dynamic Types:** Distinguishing between the static type assigned at compile time and the dynamic type an expression may evaluate to at runtime, ensuring that the dynamic type conforms to its static type.

In addition to type checking, the semantic analyzer performs several other validations, including:

- **Class and Method Definitions:** Verifying that classes are not redefined and that method names are not declared multiple times within the same class.
- **Inheritance Rules:** Confirming that inheritance follows single inheritance, that the inheritance graph contains no cycles, and that every parent class is defined in the program.
- **Method Redefinition:** Checking that any redefinition of a method in a child class has the same number of arguments, parameter types, and return type as the original method in the parent class.
- **Attribute Definitions:** Ensuring that inherited attributes are not redefined.
- **Main Class Requirement:** Confirming that every program has a class `Main` with a `main` method that takes no formal parameters and is defined in the `Main` class.
- **Identifier Bindings:** Making sure that every object identifier is declared in the innermost scope containing its declaration or as an attribute if no local declaration exists.
- **Handling of `self`:** Enforcing that the `self` identifier is not assigned to or bound in a let, case, or as a formal parameter, and that no attribute is named `self`.
- **Case Expressions:** Verifying that variables declared in each branch of a case expression have distinct types.
- **Arithmetic and Comparison Operations:** Ensuring that arithmetic operations use operands of type `Int` and that comparison operations (except for equality) also use `Int` operands. For equality operations, if either operand has a static type of `Int`, `Bool`, or `String`, then the other must match; other types, including `SELF TYPE`, may be compared freely.

The semantic analyzer relies on a comprehensive environment framework that includes a method environment, an object environment, and the current class context. This framework is essential for tracking identifier types, scopes, and bindings throughout the program. Beyond type checking, the semantic analyzer performs a range of validations—from verifying proper method redefinitions and attribute usage to enforcing inheritance rules and ensuring that all identifiers are declared in their correct scopes. This holistic approach guarantees that the program not only adheres to Cool's type rules but is also semantically sound and well-structured.

### LLVM IR Generation

The LLVM IR generation phase translates the semantically validated AST into LLVM Intermediate Representation (IR), forming the bridge between high-level Cool constructs and the final executable code. In this phase, the compiler traverses the AST and generates the corresponding LLVM IR instructions for various constructs, including expressions, control structures, and method calls.

Key aspects of the LLVM IR generation include:

- **AST Traversal and Translation:** The compiler systematically walks the AST, mapping each language construct—such as arithmetic expressions, conditionals, loops, and function calls—to its LLVM IR counterpart.
- **Handling Inheritance and Method Dispatch:** The code generation process accurately reflects the object-oriented features of Cool. It manages class inheritance, method definitions, and dynamic dispatch, ensuring that method calls and attribute accesses are correctly represented in the IR.
- **Arithmetic Operations and Built-ins:** Arithmetic expressions are converted into LLVM instructions, while built-in functions (e.g., for I/O operations) are mapped to their corresponding LLVM routines.
- **Helper Modules and Modular Design:** The IR generation logic is organized into helper functions and modular components, making it easier to maintain and extend. This design facilitates a clear separation between different aspects of code generation, such as handling expressions, method calls, and class inheritance.
- **Testing and Verification:** A dedicated test suite ensures that the generated IR is correct and that it produces the expected behavior when processed with the LLVM toolchain.

This phase is crucial as it converts the high-level, semantically rich AST into a lower-level representation that can be optimized and ultimately linked into a runnable binary.

### Built-in Functions and Basic Classes
This compiler  supports the built-in functions provided by Cool's basic classes. These functions are essential for I/O operations, string manipulation, and fundamental object behaviors, and are implemented according to the Cool language specification.

#### IO Class
- **out_string(x : String) : SELF_TYPE**  
  Prints the string `x` to the standard output and returns the calling object.
- **out_int(x : Int) : SELF_TYPE**  
  Prints the integer `x` to the standard output and returns the calling object.
- **in_string() : String**  
  Reads a string from the standard input.
- **in_int() : Int**  
  Reads an integer from the standard input.

*Note:* Any class can utilize these I/O methods by inheriting from the IO class. However, it is an error to redefine the IO class.

#### String Class
- **length() : Int**  
  Returns the length of the string.
- **concat(s : String) : String**  
  Concatenates the current string with the string `s` and returns the result.
- **substr(i : Int, l : Int) : String**  
  Returns a substring of the current string starting at index `i` with length `l`.

*Note:* It is an error to inherit from or redefine the String class.

#### Object Class
- **abort() : Object**  
  Terminates the program execution.
- **type_name() : String**  
  Returns a string representing the name of the object's class.
- **copy() : SELF_TYPE**  
  Returns a shallow copy of the object.

*Note:* It is an error to inherit from or redefine the Object class, as well as from the Int class.

These built-in functions are integral to the language, providing essential functionality for I/O operations and basic object behaviors. They ensure that every Cool program has a consistent and reliable foundation for both input/output and core object-oriented operations.## Project Structure

Here's an overview of the key directories and files in the project:

- **`ast/`**  
  Contains data structures and utilities related to the Abstract Syntax Tree (AST). This includes classes and methods for representing and manipulating the AST.

- **`codegen/`**  
  Responsible for generating LLVM IR from the semantically analyzed AST. It includes files for handling built-in functions (`builtins.go`), expression code generation (`expressions.go`), inheritance logic (`inheritance.go`), and method code generation (`methods.go`). Tests for this phase (`codegen_test.go`) are also located here.

- **`lexer/`**  
  Implements the lexer that tokenizes the Cool source code (`lexer.go`). The accompanying test file (`lexer_test.go`) verifies correct tokenization and error handling.

- **`parser/`**  
  Houses the parser (`parser.go`) and its associated test suite (`parser_test.go`). Also includes the AST printer (`ast_printer.go`) and a serializer (`serializer.go`) to aid in debugging and output formatting.

- **`semant/`**  
  Contains the semantic analyzer (`semant.go`), which enforces type safety and other semantic rules. The symbol table implementation (`symboltable.go`) supports scope and type checking. Test cases (`semant_test.go`) verify correctness.

- **`compiler_test.go`**  
  A top-level test file that  integrate and validate the entire compiler’s functionality.


## Build and Installation Instructions
### Prerequisites
- **Go** (version 1.19+ recommended)  
  Make sure Go is installed and added to your system’s `PATH`.
- **LLVM** (version 14+ recommended)  
  Install LLVM from your package manager or from [llvm.org](https://llvm.org/).  

### Build Steps
1. **Clone the Repository**  
   ```bash
   git clone https://github.com/imanefjer/COOL-Compiler.git
   ```
2. **Navigate to the Project Directory**
   ```bash
   cd COOL-Compiler
   ```
3. **Edit Target Triple (Important!)**
Open codegen.go and locate the line:
``` Go
module.TargetTriple = "arm64-apple-macosx"
```
Change "arm64-apple-macosx" to match your system’s target triple (e.g., "x86_64-pc-linux-gnu" or "x86_64-apple-macosx", depending on your environment).
### Running the Compiler
To compile a Cool file (for example, `yourfile.cool`) you should 
 #### Generate LLVM IR
Use the following command to translate the Cool  source code into LLVM IR by running:

```bash
go run main.go -i yourfile.cool
```

#### Compile to Executable

Compile the generated LLVM IR into an executable using clang:
```bash
clang -Wno-override-module yourfile.ll -o yourfile -lc
```
Here, the -Wno-override-module flag suppresses specific warnings, and -lc links the C standard library.
#### Run the Executable
Once compilation is successful, run the executable with:
```bash
./yourfile
```

#### (Optional) Clean Up

If you need to remove the generated files (set.ll and the executable), use:
```bash
rm set.ll set
```
## Testing
### Test Cases
The project includes a comprehensive test suite that covers all major components of the compiler, including the lexer, parser, semantic analyzer, and LLVM IR generation. Each set of tests ensures that tokenization, AST construction, type checking, and code generation work as expected, while also verifying proper error handling. In addition, a dedicated `compile_test.go` is provided to test the entire compiler on a variety of input programs—from simple cases to more complex examples that include inheritance, method overriding, and arithmetic operations.

### Running Tests
To execute the entire test suite, run the following command in the root directory of the project:
```bash
go test -v ./...
```

## Extensions

### Module System
This project includes experimental support for a module system, allowing you to organize your Cool programs into separate files and import them as needed. This modular approach promotes cleaner code organization and reusability across different parts of your application.


### Standard Library Extension: LinkedList
An additional extension provided in this project is a LinkedList implementation, which is defined in the `linkedList.cool` file. This standard library extension offers a range of operations to manage linked lists effectively, including:
- **addFirst(element):** Adds an element to the beginning of the list.
- **addLast(element):** Adds an element to the end of the list.
- **removeFirst():** Removes the first element from the list.
- **removeLast():** Removes the last element from the list.
- **get(index):** Retrieves the element at the specified index.
- **size():** Returns the number of elements in the list.
- **isEmpty():** Checks whether the list is empty.

## Example Program

Below is an example Cool program that demonstrates class inheritance, method overriding, and object copying:

```cool
class Animal {
    name : String <- "Unknown";

    init(n : String) : Animal {
        {
            name <- n;
            self;
        }
    };

    getName() : String {
        name
    };
    
    print() : Object {
        (new IO).out_string("This is an animal\n")
    };
};

class Dog inherits Animal {
    breed : String <- "Mixed";

    init(n : String) : Dog {
        {
            name <- n;
            self;
        }
    };

    getBreed() : String {
        breed
    };
    
    print() : Object {
        (new IO).out_string("This is a dog\n")
    };
};

class Main inherits IO {
    main() : Object {
        {
            let myDog : Dog <- (new Dog).init("Buddy") in {
                out_string("Dog name: ");
                out_string(myDog.getName());
                out_string("\n");
                
                out_string("Dog breed: ");
                out_string(myDog.getBreed());
                out_string("\n");
                
                out_string("Dog print method: ");
                myDog.print();
                
                out_string("Animal print method: ");
                myDog@Animal.print();
                
                out_string("Copy name: ");
                let dogCopy : Dog <- myDog.copy() in {
                    out_string(dogCopy.getName());
                    out_string("\n");
                };
            };
        }
    };
};
```
#### Program Output
```
Dog name: Buddy
Dog breed: Mixed
Dog print method: This is a dog
Animal print method: This is an animal
Copy name: Buddy
```
#### This Example Demonstrates:
- Creating an instance of `Dog` and initializing it with a name.
- Using overridden methods in the `Dog` class and inherited methods from the `Animal` class.
- Invoking methods from both the child (`Dog`) and parent (`Animal`) classes.
- Copying an object using the built-in `copy()` method.

